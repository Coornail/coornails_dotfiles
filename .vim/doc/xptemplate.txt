*XPTemplate*	For Vim version 7.2. Last change: 2009 Apr 16
*xptemplate*
*xpt*


			XP's Snippet Template engine
								    by drdr.xp
							     drdr.xp@gmail.com

	Generate customizable code snippets automatically.

	|xpt-install|
	|xpt-usage|
	|xpt-feature|
	|xpt-option|
	|xpt-key-bind|
	|xpt-api|
	|xpt-changes-log|

								 *xpt-install*
	Copy files and directories into one of your |runtimepath|s.

							       *xpt-uninstall*
	:XPTuninstall

								   *xpt-usage*
	In insert mode, after typed key of a template, pressing <C-\> to
	generate a snippet. Using <Tab> to navigate through snippet template.
	For examle, vim xpt.c, : >
		for<C-\>
<	Generates : >
		for (i = `0^; i < `len^; ++i){
		  `cursor^
		}
<	"i" being selected is the current item you are editing. `0^ is next
	item,  and you can navigate to it by typing <Tab> |xpt-navigate-key|.

	Now type "abcdefg", this snippet result in : >
		for (abcdefg = `0^; abcdefg < `len^; ++abcdefg){
		  `cursor^
		}
<	Now press <Tab>, cursor will jumps to next item "0": >
		for (abc = 0; abc < `len^; ++abc){
		  `cursor^
		}
<
	More usages are described blow:

								 *xpt-feature*
	On time typing update
	Popup hint					|xpt-hint|
	Context sensitive template generation		|xpt-context|
	High light currently typed item
	Embedded functions and variables		|xpt-function|
	Repeatable template generation			|xpt-repeatable|
	Nested template					|xpt-nested|
	Wrapping template				|xpt-wrapped|
	Auto indent					|xpt-auto-indent|
	Cursor position helper				|xpt-cursor-protection|
	Named item or anonymous item			|xpt-item|
	Alternative item default value			|xpt-default-value|
	and more......

						      *xpt-popup*   *xpt-hint*
	If you type nothing or incompleted template key and press <C-\>, a
	popup menu shows up listing all possible template key. For example : >
		fo<C-\>
<	Shows : >
		for
		forr
<
	After select the item from popup menu, press <C-\> again to trigger
	template

							      *xpt-nested*
	Template can expand inside another template. There is no difference
	between using a nested template or top-level template.
	For example, when you edit xp.c . type siwtch<C-\>, generate a switch
	block template: >
		switch (fn) {
		  case 0 :
			<--------------cursor stops here
		    break;
		    `...^
		  default:
			`^
		}
<	Now the cursor stops between "case 0 :" and "break;", type : >
		if<C-\>
<	It becomes : >
		switch (fn) {		# upper level template
		  case 0 :		#
		    if (){		. nested template
		      `cursor^		.
		    }			.
		    break;		# upper level template
		    `...^               #
		  default:              #
			`^              #
		}                       #
<	Type <Tab>, <Tab>.. to navigate out of the nested template : >
		switch ("xp.c" == fn) {
		  case 0 :
		    if (){

		    }
		    break;

		  default:
			<--------------cursor stops here
		}
<	Now cursor stops after "default:", and we get out back to the "switch"
	template
							      *xpt-auto-indent*
	Template is autdo indented when the first time it shows up on screen,
	your typing in template and after template rendering.

==============================================================================

								     *xpt-api*
	Templates are defined in filetype plugins. You can find them all in
	ftpplugin/**/*.template.vim
	You can add new template just by creating another ftplugin file.
	And you can include other template file in your template file. see
	|xpt-include|.

	Define new template is easy, for example : >
		call XPTemplate("inc", 'include <`^.h>')
<	Defines the "include" template. Item quoted by |`| and |^| are
	replaced by user typing. Function maybe used in ftplugin
	scripts:
	|XPTemplate()|		define new template
	|XPTemplateMark()|	define new template mark in current buffer
	|XPTfuncs()|		get function container
	|XPTvars()|		get variable container

							  *xpt-template-files*
	There are several files with XPTemplate : >
	/_comment_c_like/cmt.template.vim	comment template
	/_common/common.template.vim		commonly used template
	/c/c.template.vim			c template
	/c/wrap.template.vim			c wrapping template
	/help/help.template.vim			vim help template
	/html/html.template.vim			html template
	/javascript/javascript.template.vim	js template
	/sh/sh.template.vim			shell script template
	/vim/vim.template.vim			vim script template
	/vimtemplate/t.template.vim		for this plugin
<

								 *xpt-include*
	You can include another template file in any *.template.vim file : >
		runtime ftplugin/_common/common.template.vim
<
							 *xpt-common-template*
	"common" template defines templates and function and variables  maybe
	used somewhere else. And itself is a sample of how to use variables and
	function in template.

						     *xpt-define-new-template*
								    *xpt-item*
	In defining template, you have to specify in template which part can
	be edit by user, that is done by quoting part of template by mark.
	By default, the left mark is |`|, the right mark is |^|. for example : >
		call XPTemplate("for", ""
		      \."for (`i^ = `0^; `i^ < `len^; ++`i^){\n"
		      \."  `cursor^\n"
		      \."}")
<	This defines for loop template for c language. In it there are 4 item
	can be edited : >
		i, 0, len, cursor
<	For more infomation about item, see |xpt-item-format|

							*`*   *^*   *xpt-mark*
	Default template mark to specify the editable part of a template. They
	can be changed locally(to current buffer) by calling |XPTemplateMark()|.

							     *xpt-item-format*
	Item is composed as follow :
	|`| |xpt-item-name| |^| [|xpt-default-value| |^| [|^|]]

							       *xpt-item-name*
	Item name is the text between |`| and |^|. It can be plain text, |xpt-variable|,
	|xpt-function|. But can NOT be mixed and you will never need mixed
	item :).
	Before you can jump to the first item, all items with |xpt-variable|
	and |xpt-function| will be evaluated.

							   *xpt-format-normal*
	Normal format is |`| |xpt-item-name| |^|. As you navigate to such an
	item, |xpt-item-name| is evaluated and selected as default value.

							  *xpt-format-default*
	|`| |xpt-item-name| |^| |xpt-default-value| |^| is default value
	format let you specify some other text as default value when navigated
	to this item. |xpt-default-value| can be plain text, |xpt-variable|,
	|xpt-function| or mixed.

						  *xpt-format-delayed-default*
	Delayed default value format :
	|`| |xpt-item-name| |^| |xpt-default-value| |^| |^|

	It is similar with |xpt-format-default|. The only difference is when
	you jump to such item, |xpt-item-name| is selected and you can edit as
	well. Like |xpt-format-normal|. But when you jumps to next item
	leaving the original text of |xpt-item-name| there , the
	|xpt-default-value| replaces the left text. 


							   *xpt-default-value*
	By default, an Item being selected uses its name as the default value,
	but you have a chance to choose other text as default value, and it is
	easy to be done: fill the text following the item and end it with
	right mark |^| : >
		`item_name^default_value^
<	The default value can be plain text, |xpt-variable|, |xpt-function| or
	mixed. For example : >
		call XPTemplate("ind", 'include "`^fileRoot()^.h"')
<	In upper case, the unnamed item with an alternative default value
	defined by a function. see |xpt-function|.
	Example : type "#ind<C-\>": >
		#include "current_file_name.h"
<

						     *`cursor^*   *xpt-curosr*
	The item of name "cursor" is a special one. It always is selected at
	last and replaced with empty string. When navigate to "cursor" item,
	template is complete.

						     *`^*    *xpt-unmaed-item*
	You can specify unnamed item bu just leave the name empty, : >
		call XPTemplate("fun", [
		      \"  `int^",
		      \"`name^(`^)",
		      \"{",     \__________unnamed item
		      \"  `cursor^",
		      \"}"
		      \])
<	The function parameter is a unnamed item. Each unnamed item is a
	unique one and different unnamed items will not be treated as with the
	same name : empty string.

						   *`...^*    *xpt-repeatable*
	Some segment can be defined as repeatable, for example the "case"s in
	"switch". To specify the repeatable part is easy, just wrap the part
	you want it to repeat with `...^ . Take the case from "switch": >
		call XPTemplate('switch', [
		      \ 'switch (`^) {',
		      \ '  `...^',            | repeatable part
		      \ '  case `^0^ :',      |
		      \ '    `^',             |
		      \ '    break;',         |
		      \ '  `...^',            |
		      \ '',
		      \ '  default:',
		      \ '    `^',
		      \ '}'
		      \])
<
	When you trigger a repeatable template, it works as below : >
		switch () {    <-------cursor stays here,
		  `...^

		  default:
		      `^
		}
<	Press <tab>, the |`...^| becomes as below, and the 4 lines expanded
	from |`...^| are selected. These 4 lines are repeatable part, : >
		switch () {

		  case `17^ :       | selected
		    `^              |
			break;      |
		    `...^           |

		  default:
			`^
		}
<	Now, press <cr>|s_CR| to cancel repeatable part and go to next item.
	Or press <tab>|s_TAB| to enter the repeatable part. You may have
	noticed there is another |`...^|, that is the another repeat trigger.

	Press <tab> 3 times : >
		switch () {

		  case 0 :

		    break;

		  case `20^ :      | selected repeatable part
		    `^             |
			break;     |
		    `...^          |

		  default:
			`^
		}
<

						   *`wrapped^*   *xpt-wrapped*
	Define the template : >
		call XPTemplate('invoke_', [
		      \ '`name^(`wrapped^)'
		      \])             \_______wrapped item
<	And in a file use |V| to select some text, press<C-\> |v_CTRL-\|. The
	selected text is yanked and removed, A popup menu appears to let you
	select template name. : >
		a, b
	press V to select this line,<C-\>, in popup, select "invoke_", it
	shows:
		name(a, b)
<	Now edit the name.

					       *xpt-function*   *xpt-variable*
	*TODO*
	You can use 2 global function to get function or variable container to
	define functions or variables used as |xpt-default-value|.

								 *xpt-context*
	You can define template that can only be triggered at certain
	circumstancesstances. For example in certain syntax.
	Defining context denpended template is by adding another parameter to
	XPTemplate call "{'syn' : 'the context name'}" : >
		call XPTemplate("para", {'syn' : 'comment'}, "
			\@param {`Object^} `name^ `desc^")
<	Now only in syntax of name like "comment", template "para" can be
	triggered.

								*XPTemplate()*
XPTemplate({name}, [, {context}], {template})
	"XPTemplate" defines a template to current buffer. It takes 2 or 3
	parameters:
	{name} is string representing the key to trigger this template.
	{context} can be omit or an |Dictionary| defines where this template
	can be triggered. For now only "syn" is supported.
	{template} can be string or |List|. |List| will be joined with "\n"
	forming a template string. This saves you adding "\n" to each line.

							    *XPTemplateMark()*
XPTemplateMark({leftmark}, {rightmark})
	XPTemplateMark defines what chars are used as item quoter. It only
	takes effect to current buffer. See |xpt-mark|

						      *XPTfuncs()* *XPTvars()*
g:XPTfuncs()   g:XPTvars()
	g:XPTfuncs() returns a |Dictionary| container of functions can be used
	in template in current buffer. The normal using of g:XPTfuncs() to
	define a template function is : >
		let s:f = g:XPTfuncs()

		fun! s:f.date() dict
		  return strftime("%Y %b %d")
		endfunction
<
	g:XPTvars() returns a |Dictionary| container of variables can be used
	in template in current buffer. For example : >
		let s:v = g:XPTvars()

		let s:v['$author'] = "drdr.xp"
<
	Now  can use function or variables in template : >
	call XPTemplate("filehead", [
	      \'/**--------------------/// `sum^ \\\----------------------',
	      \' *',
	      \' * @version : `1.0^',
	      \' * @since : `date()^',
	      \' * @author : `$author^ | `$email^',
	      \' * @copyright `.com.cn^ ',
	      \' * @TODO : ',
	      \' * ',
	      \' *---------------------\\\ `sum^ ///----------------------*/',
	      \''])
<
==============================================================================

								*xpt-key-bind*
	Default key binds to trigger template are |i_CTRL-\| and |v_CTRL-\|.
	And with |g:xptemplate_key| option you can override them.

								    *i_CTRL-\*
	Trigger template in insert mode.
								    *v_CTRL-\*
	Trigger template with selected text in visual mode. Text you selected
	will be wrapped within "wrapped" item. See |xpt-wrapped|

					*xpt-navigate-key*   *i_TAB*   *s_TAB*
	Navigate to next item.

							  *xpt-clear*   *s_CR*
	Clear current item and jump to next.
								    *s_CTRL-l*
	Jump to the end of current item in insert mode.

==============================================================================

								  *xpt-option*
	Options can be set in |.vimrc| to modify xptemplate behavior.

							    *g:xptemplate_key*
							       {default:<C-\>}
	The key to trigger template. See |i_CTRL-\| |v_CTRL-\|.

						     *g:xptemplate_strip_left*
								   {default:1}
	When set, wrapping template |xpt-wrapped| removes space before line.

			 *xpt-cursor-protection*   *g:xptemplate_limit_curosr*
								   {default:1}
	When set, cursor is hold where it should be, but this will slow down
	a bit template rendering.

						      *g:xptemplate_highlight*
								   {default:1}
	When set, items with the same name of current item is highlighted.

						     *g:xptemplate_show_stack*
								   {default:1}
	When set, at the left of |statusline|, nested template |xpt-nested|
	are showed : >
		XPT:for[len] > if[]
<	Indicate rendering template "if" inside template "for".

						       *g:xptemplate_to_right*
							     {default:"<C-l>"}
	Change the default key |s_CTRL-l| to jump to item end in |Select-mode|.




==============================================================================

							     *xpt-changes-log*
: > <
Fixed:2009 Apr 21	char before template name moved to after template if 
			'virtualedit' is not set with 'onemore'
Fixed:2009 Apr 21	ruler and statusline check.Thanks christian.coutinho
Added:2009 Apr 19	plugin support
Added:2009 Apr 18	delayed default value
Fixed:2009 Apr 18	auto formating causes invalid range
Added:2009 Apr 18	default value can be mixed with variable and function
Added:2009 Apr 18	function can take parameters
Fixed:2009 Apr 18	cursor bug
Fixed:2009 Apr 18	cursor protection bug if item with no content
			some code refinement
Fixed:2009-Apr-16	format overwhelming char next to template
Fixed:2009-Apr-14	escape. at last unescape marks
Fixed:2009-Apr-14	unescape when building positionn list
Added:2009-Apr-14	format as typed
Added:2009-Apr-14	reentering insert mode cancels wrap template
Added:2009-Apr-13	out of item content protection
Fixed:2009-Apr-13	default value for item without name
Fixed:2009-Apr-12	item highlight more precisely
Fixed:2009-Apr-12	to format default value
Fixed:2009-Apr-12	repeatable template bug of escaped char
Added:2009-Apr-12	user defined template generation
Added:2009-Apr-12	on-type high light
Added:2009-Apr-12	hide cursor if only appears at last
Added:2009-Apr-12	repeatable elements `...^
Fixed:2009-Apr-12	bug of '\' in typed content
Fixed:2009-Apr-12	self nested range bug
Fixed:2009-Apr-12	inline template goes to upper line
Fixed:2009-Apr-12	update items as input
Fixed:2009-Apr-11	syntax context sensitive bug
Added:2009-Apr-11	remember alternative value before template rendering
Added:2009-Apr-11	alternative default value
Added:2009-Apr-10	new function and variable interface
Added:2009-Apr-10	zero-width item
Fixed:2009-Apr-10	do not use mark 'O' anymore
Fixed:2009-Apr-10	new function and variable definition format
Added:2009-Apr-10	render template in another tempalte nested template
Added:2009-Apr-09	strip left space for wrapping template
Fixed:2009-Apr-09	0 width content replacing problem
Added:2009-Apr-09	cursor position protect
Fixed:2009-Apr-09	more precise searching range
Added:2009-Mar-27	templating with wrapping
Fixed:2009-Mar-25	typed content with '~' is incorrectly dealed
Fixed:2009-Mar-25	using buffer-scope data to store template data
Added:2009-Mar-25	dealing with escaped template mark character correctly
Added:2009-Mar-19	add common template
Fixed:2009-Mar-17	indent bug
Fixed:2009-Mar-17	format after finishing all types
Added:2009-Mar-16	buffer depended template item mark
Added:2009-03-15	user defined variables and functions in template
Added:2009-03-14	syntax context sensitive template rendering
Fixed:2009-03-03	precise range for typed content
Fixed:2009-02-27	fix select mode mapping
Fixed:2008-06-15	fix the bug of some text being selected at start
Fixed:2008-06-15	bug of cursor at first column not being rendered correctly
Fixed:2008-06-15	fix no item bug.
Added:2008-06-15	add default cursor position at template end
Fixed:2008-06-11	bug of popup menu while no word char under cursor
Fixed:2008-06-11	bug syn highlight not cleared
Fixed:2008-06-11	bug unrecognized item at 1st column
Fixed:2008-06-11	bug first item is in insert mode not select mode
Added:2008-06-10	add tempalte complete popup
Fixed:2008-06-10	use <C-r>= instead of <esc>
Fixed:2008-06-09	move \V to pattern const
Added:2008-06-08	auto clear cursor mark and return to normal insert
Added:2008-06-08	high light cuurent variable
Added:2008-06-08	replace search navigation with search()
Added:2008-06-08	while searching & replace symbel, use very no-magic
Added:2008-06-07	migrated to vim7, use dictionary
Fixed:2008-02-13	bug with folding when template rendered
Added:2008-02-07	predefined functions
Added:2007-08-26	default value
Added:2007-08-26	predefined variables
Added:2007-08-25	cursor position
Fixed:2007-09-19	single character template bug that expanding more than one word
Fixed:2007-09-20	cursor position when no template recognized.
Added:2007-09-20	high light for current item

==============================================================================
vim:tw=78:ts=8:sw=8:sts=8:noet:ft=help:norl:
